#! /bin/sh

# NOTE: at the moment generating the classes for the isolated-class-loader-transport
# is a rather complex process. This is due to that sbt runs in scala 2.12
# but the functions-remote generator is in scala 3 which means we can't
# run it within sbt. This is going to be improved later on so that all
# the build can be configured within sbt. For now we will use scala-cli
# scripts.

# First we need to publish the exported trait locally. The published jar will be read by the code generator in order to
# generate the caller / receiver / serialization / transport classes.
sbt ls-exports/publishLocal

# Now we will create a list of dependencies for both the ls-exports 
# under ~/.functions-remote-config/. These text file is read by the isolated classloader when invoking ls-receiver
# and also by the code generator.
scala-cli scripts2.13 scripts2.13/import-dependencies-for-exports.sc

# Now we will generate the caller / receiver / serializers code for LsFunctions.
# The receiver will get the receiver-related generated code and the caller will
# get the caller-related generated code.
scala-cli scripts scripts/ls-receiver.sc
scala-cli scripts scripts/ls-caller.sc

# Now that the receiver has the generated code, we can build & publish it
sbt ls-receiver/publishLocal

# We need a list of jars for the receiver for the isolated classloader (IsolatedClassLoaderTransport) to be able to load them. The
# scripts generate a text file with the dependencies using coursier. But the classloader doesn't have any dependencies to Coursier
# because it only needs to read the text file.
scala-cli scripts2.13 scripts2.13/import-dependencies-for-receiver.sc

# Finally we are ready to call it via ls-caller.
# We will enable functions.debug so that functions-remote dumps a lot of debugging information.
sbt "-Dfunctions.debug" "ls-caller/runMain example.callLsFunctionViaAvroSerialization"
